#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     arm,           tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     wrist,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    claw,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    lock,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

//Constant defines
//-System top speeds:
#define DRIVE_CAP 100	//Maximum drive speed. lower for testing purposes
#define ARM_CAP 100
#define WRIST_CAP 50
#define FLAG_CAP 100
//-System scalars
#define ARM_SCALAR 10 //Constant that scales arm control in downward direction
//-System positions
#define LOCK_EN 180
#define LOCK_DIS 0
#define CLAW_OPEN 270
#define CLAW_CLOS 0
#define ARM_STOW 100
#define ARM_SCORE 1200	//Todo: test and change
#define ARM_UP 1650
#define ARM_HANG 300	//Todo: test and change

//Finite state machine state values;
int drive_fsm = 0;
int arm_fsm   = 0;
int manip_fsm = 0;
int flag_fsm  = 0;

void initializeRobot()
{
  return;
}

int cap(int input, int k) {
	/*int upper = k;
	int lower = k * -1;
  if(input > upper) {	//Comment out these two if statements if there are issues compiling.
    return upper;
  }
  if(input < -lower) {
    return -lower;
  }*/

  if(abs(input) < 10) {	//Deadband logic to prevent motors from creeping at low speeds.
    input = 0;
  }
  return input;
}

void driveControl() {
    int throttle = (joystick.joy1_y1*100)/128;  //FPS style drive controls
    int turning = (joystick.joy1_x2*100)/128;	//Taking inputs from input range of -128 to 127 and scaling them to -100 to 100

    turning = (turning * abs(turning))/100; //Square the turning input for controlability
    //TODO: Tweak and test drive input curves

    motor[left] = -cap(throttle+turning, DRIVE_CAP);  //output drive inputs
    motor[right] = cap(throttle-turning, DRIVE_CAP);
}

int lockInput = 0;
int armInput = 0;
int armPos = 0;
int armSet = 0;
//Arm FSM values:
//0 - Scoring - open loop
//1 - Scoring - closed loop
//2 - Hanging
//3 - Locked
//4 - zero encoder
void armControl() {
    armInput = 0;
    armPos = nMotorEncoder[arm];
    float armP = .33;

    if(arm_fsm == 0) {
    	armInput = joystick.joy2_y2;	//manual input, joystick controls power
    	if(armInput < 0)  //scale arm input in downward direction for controlability
    	{
	      armInput /= ARM_SCALAR;
    	}
  	} else if(arm_fsm == 1) {

    	if(joy2Btn(2)) {
    		armSet = ARM_STOW;
  		} else if(joy2Btn(3)) {
  			armSet = ARM_SCORE;
  		}	else if(joy2Btn(4)){
  			armSet = ARM_UP;
  		}
  		armInput = (int)(((float)(armSet - armPos))*armP);	//Closed loop P positioning
  	} else if(arm_fsm == 2) {
  		armSet = ARM_HANG;
  		armP = 2.0;
  		armInput = (int)(((float)(armSet - armPos))*armP);	//Closed loop P positioning
  		lockInput = LOCK_DIS;

  		if((armPos - armSet) < 100) {
  			arm_fsm = 3;
  		}
  	} else if(arm_fsm == 3) {
  		armInput = 0;
  		lockInput = LOCK_EN;
  	} else if(arm_fsm == 4) {
  		nMotorEncoder[arm] = 0;
  	}

    servo[lock] = lockInput;
    motor[arm]= cap(armInput, ARM_CAP);

}

void manipulatorControl() {
    if(joy2Btn(5)) {
      servo[claw] = CLAW_OPEN;
    } else {
      servo[claw] = CLAW_CLOS;
    }

    int wristInput = 0;
    wristInput = joystick.joy2_y1/5;
    motor[wrist] = cap(wristInput,WRIST_CAP);

}

void flagControl() {
	    int flagInput = 0;

    if(joy1Btn(2))
    {
      flagInput=10;       //Slow speed for alignment
    } else if(joy1Btn(3))
    {
      flagInput=70;       //Med speed for slow rise
    } else if(joy1Btn(4))
    {
      flagInput = 100;    //fast speed for fast rise
    }

    if(joy1Btn(9)) {  //inversion button just in case
      flagInput = -flagInput;
    }

    motor[flag] = flagInput;

}

task main()
{
  initializeRobot();
  waitForStart();   // wait for start of tele-op phase

  arm_fsm = 1;	//arm_fsm = 0;

  while (true)
  {
    getJoystickSettings(joystick);	//Required for driver control

    if(joy1Btn(9) && joy1Btn(10)) {
    	arm_fsm = 2;
  	}

		driveControl();
		armControl();
		manipulatorControl();
		flagControl();
  }
}
